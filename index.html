<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Mjson : Lean JSON Library for Java, with a compact, elegant API." />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Mjson</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/bolerio/mjson">View on GitHub</a>

          <h1 id="project_title">Mjson</h1>
          <h2 id="project_tagline">Lean JSON Library for Java, with a compact, elegant API.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/bolerio/mjson/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/bolerio/mjson/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a name="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages"><span class="octicon octicon-link"></span></a>Welcome to mJson.</h3>

<p>mJson is an extremely lightweight Java JSON library with a very concise API. It is implemented entirely in a single class called Json. Unlike other JSON libraries, it focuses on manipulating JSON structures in Java without necessarily mapping them to/from strongly typed Java objects. The main goal is to reduce verbosity and work with JSON in Java as naturally as in JavaScript. Yes, JSON is naturally embedded in JavaScript, so syntactically it could never be as easy in a Java context, but it still doesn't make much sense to have strongly typed JSON elements when the structures are dynamic and untyped to being with. For example in GSON, and pretty much all other libraries, one ends up suffering the verbosity of strong typing, with type casts all over the place, without getting any of the benefits. If you are writing REST services that work directly with JSON and you're not mapping it to Java, i.e. if you're using JSON as structured data that both client and server can work with, mJson would be a better choice. If you need more control and would like to enchance it with automatic beans to/from Json mappings or you would like to change how Json elements are represented internally, mJson allows you to do that as well!</p>

<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Features</h3>

<ul class="task-list">
<li>Full support for <a href="http://json-schema.org/">JSON Schema Draft 4</a> validation</li>
<li>Single universal type - everything is a <code>Json</code>, no type casting</li>
<li>Single factory method, no new operators, just call <code>Json.make(anything here)</code>
</li>
<li>Fast, hand-coded parsing</li>
<li>Designed as a general purpose data structure for use in Java</li>
<li>Parent pointers and <code>up</code> method to traverse the JSON structure</li>
<li>Concise methods to read (<code>Json.at</code>), modify (<code>Json.set</code>, <code>Json.add</code>), duplicate (<code>Json.dup</code>), merge (<code>Json.with</code>) </li>
<li>Flexible merging of deep structures, see <a href="https://github.com/bolerio/mjson/wiki/Deep-Merging" target="_blank">Deep Merging</a></li>
<li>Methods for type-check (e.g. <code>Json.isString()</code>) and access to underlying Java value (e.g. <code>Json.asString()</code>)</li>
<li>Method chaining</li>
<li>Pluggable factory to build your own support for arbitrary Java&lt;-&gt;Json mapping</li>
<li>1 Java file is the whole library with no external dependencies</li>
</ul>

<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Wish List</h3>

<p><a href="mailto:borislav.iordanov@gmail.com">Get in touch</a> if you want to help!</p>

<ol class="task-list">
<li>Traversal API</li>
<li>Search with pattern-matching</li>
</ol>

<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Get It</h3>

<p>
It is in Maven central, so add this to your pom.xml if you are using Maven:
</p>

<pre><code><dependency>
  &lt;groupId&gt;org.sharegov&lt;/groupId&gt;
  &lt;artifactId&gt;mjson&lt;/artifactId&gt;
  &lt;version&gt;1.4.0&lt;/version&gt;
</dependency>
</code></pre>

<p>You can also simply get the Json.java from the GitHub project and include it in your project. Or download a jar build from:</p>

<a href="http://repo1.maven.org/maven2/org/sharegov/mjson/1.4.0/mjson-1.4.0.jar">Direct link to mjson-1.4.0.jar at Maven Central</a>

<p>
Or get the latest snapshot (deployed snapshots are generally stable and contain 
latest functionality): 
</p>

<pre><code><dependency>
  &lt;groupId&gt;org.sharegov&lt;/groupId&gt;
  &lt;artifactId&gt;mjson&lt;/artifactId&gt;
  &lt;version&gt;1.5-SNAPSHOT&lt;/version&gt;
</dependency>
</code></pre>

<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>
Extensions
</h3>

<p>
A separate project collects extension modules to the library. While most other libraries bundle all functionality in one package,
undersandably for convenience, we have instead opted to to keep the library as small as possible and with 0 external dependencies.
So "big" functional areas are covered by this separate project, to be found at: 
<a target="_blank" href="https://github.com/bolerio/mjson-ext">https://github.com/bolerio/mjson-ext</a>.
</p>


<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>
Complete API Tour
</h3>

<p>This will walk you through all API methods by functional areas: 
<a href="https://github.com/bolerio/mjson/wiki/A-Tour-of-the-API">A Tour of the API Wiki</a>
</p>

<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Javadoc</h3>

<p>To start using this library, you only need to glance at the example and method description on the Javadoc:
</p>

<p>
<a href="apidocs/index.html">Json API</a>
</p>

<h3>
<a name="rather-drive-stick" class="anchor" href="#rather-drive-stick"><span class="octicon octicon-link"></span></a>Background</h3>

<p>
JSON (JavaScript Object Notation) is a lightweight data-interchange format. You knew that already. If not, continue reading on <a href="http://www.json.org">http://www.json.org</a>.
</p>

<p>
It is supposed to be about simplicity and clarity. Something minimal, intuitive, direct. Yet, I could not find a Java library to work with it in this way (well, in 2011 at least). The GSON project is pretty solid and comprehensive, but while working with REST services and coding some JavaScript with JSON in between, I got frustrated of having to be so verbose on the server-side while on the client-side manipulating those JSON structures is so easy. The others like Jackson, Jettison etc. seemed even worse. So, after a lot of hesitation and looking over all Java/JSON I could find (well, mostly I examined all the libraries listed on json.org), I wrote yet another Java JSON library. It was developed in the context of the <a href="https://github.com/sharegov/opencirm">OpenCiRM</a> project, but because it is rather independent from the rest of the project, I separated it. And because it has a chance of meeting other programmers' tastes, I decided to publish it.
</p>

<p>
The library is called mjson for "minimal JSON". The source code is a single Java file (also included in the distribution jar). Some of it was ripped off from other projects and credit and licensing notices are included in the appropriate places. The license is Apache 2.0.
</p>

<h3>
<a name="rather-drive-stick" class="anchor" href="#rather-drive-stick"><span class="octicon octicon-link"></span></a>Design</h3>

<p>
The goal of this library is to offer a simple API to work with JSON structures, directly, minimizing the burdens of Java's static typing and minimizing the programmer's typing (pun intended).
</p>

<p>
To do that, we emulate dynamic typing by unifying all the different JSON entities into a single type called Json. Different kinds of Json entities (primitives, arrays, objects, null) are implemented as sub-classes (privately nested) of Json, but they all share the exact same set of declared operations and to the outside world, there's only one type. Most mutating operations return this which allows for a method chaining. Constructing the correct concrete entities is done by factory methods, one of them called make which is a "do it all" constructor that takes any Java object and converts it into a Json. Warning: only primitives, arrays, collections and maps are supported by default. Handling Java bean mappings can be done by customizing the factory methods - there's an interface for that called <code>Json.Factory</code>.
</p>

<p>
As a result of this strategy, coding involves no type casts, much fewer intermediary variables, much simpler navigation through a JSON structure, no new operator every time you want to add an element to a structure, no dealing with a multitude of concrete types. Overall, it makes life easier in the current era of JSON-based REST services, when implemented in Java that is.
</p>

<p>
In a sense, we are flipping the argument from the blog <a href="http://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/">Dynamic Languages Are Static Languages</a> and making use of the universal type idea in a static language. Java already has a universal type called Object, but it doesn't have many useful operations. Because the number of possible JSON concrete types is small and well-defined, taking the union of all their interfaces works well here. Whenever an operation doesn't make sense, it will throw an UnsupportedOperationException. But this is fine. We are dynamic, we can guarantee we are calling the right operation for the right concrete type. Otherwise, the tests would fail!
</p>

<h3>
<a name="rather-drive-stick" class="anchor" href="#rather-drive-stick"><span class="octicon octicon-link"></span></a>A Quick Example</h3>

<code><pre>import mjson.Json;

Json x = Json.object().set("name", "mjson")
                      .set("version", "1.0")
                      .set("cost", 0.0)
                      .set("alias", Json.array("json", "minimal json"));
x.at("name").asString(); // return mjson as a Java String
x.at("alias").at(1); // returns "minimal json" as a Json instance
x.at("alias").up().at("cost").asDouble(); // returns 0.0

String s = x.toString(); // get string representation

x.equals(Json.read(s)); // parse back and compare => true
</pre></code>

<p>
For more, read the Javadoc at the link above. No point in repeating it here.
</p>

<p>
We are at an official release of version 1.3 which incorporate JSON Schema validation. Suggestions for further enhancements are welcome! Besides some simple nice-to-haves, such as pretty printing or the ability to stream to an OutputStream, pre-packaged Java bean mappings might turn out to be justified after all. Also, jQuery style selectors and a richer set of manipulation operations. Lambdas in Java 8 certainly open interesting API possibilities. For now, we are keeping it simple. The main use case is if you don't have a Java object model for the structured data you want to work with, you don't want such a model, or you don't want it to be mapped exactly and faithfully as a JSON structure.
</p>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Mjson maintained by <a href="https://github.com/bolerio">bolerio</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
